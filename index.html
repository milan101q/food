<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Culinary Alchemist</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .font-lora {
            font-family: 'Lora', serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #8B5CF6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="module">
        // Polyfill for process.env
        window.process = {
            env: {
                // The API_KEY is injected by the execution environment.
                API_KEY: window.aistudio?.getApiKey()
            }
        };
    </script>
    <script type="text/babel" data-type="module">
        // Import from CDN
        import { GoogleGenAI } from "https://esm.run/@google/genai";

        // ========================================================================
        // --- START OF types.ts ---
        // ========================================================================
        const AppState = {
            IDLE: 'IDLE',
            ANALYZING: 'ANALYZING',
            SUGGESTING: 'SUGGESTING',
            GENERATING_IMAGE: 'GENERATING_IMAGE',
            DISPLAYING_RECIPE: 'DISPLAYING_RECIPE',
            GENERATING_VIDEO: 'GENERATING_VIDEO',
            DISPLAYING_VIDEO: 'DISPLAYING_VIDEO',
            COOKING: 'COOKING',
            ERROR: 'ERROR',
        };

        const Language = {
            EN: 'en',
            FA: 'fa',
        };

        // ========================================================================
        // --- END OF types.ts ---
        // ========================================================================


        // ========================================================================
        // --- START OF i18n/translations.ts ---
        // ========================================================================
        const translations = {
            en: {
                title: "Culinary Alchemist",
                subtitle: "Transform your ingredients into master dishes.",
                uploadPrompt: "Upload a photo of your ingredients",
                uploadButton: "Choose an image",
                analyzing: "Analyzing ingredients...",
                suggestionsPrompt: "Here are a few ideas:",
                generateRecipe: "Generate Recipe",
                generatingRecipe: "Generating Recipe...",
                generatingImage: "Painting a picture of your dish...",
                generatingVideo: "Directing your cooking video...",
                startCooking: "Start Live Cooking Assistant",
                videoReady: "Your cooking video is ready!",
                watchVideo: "Watch Video",
                startOver: "Start Over",
                error: "An unexpected error occurred. Please try again.",
                cookingAssistantTitle: "Live Cooking Assistant",
                listening: "Listening...",
                speakNow: "Speak now...",
                processing: "Processing...",
                micIsOff: "Microphone is off",
                user: "You",
                assistant: "Assistant",
                endSession: "End Session",
                confirmEndSession: "Are you sure you want to end the session?",
                yes: "Yes",
                no: "No",
            },
            fa: {
                title: "Ú©ÛŒÙ…ÛŒØ§Ú¯Ø± Ø¢Ø´Ù¾Ø²ÛŒ",
                subtitle: "Ù…ÙˆØ§Ø¯ Ø§ÙˆÙ„ÛŒÙ‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ ØºØ°Ø§Ù‡Ø§ÛŒ Ø§Ø³ØªØ§Ø¯Ø§Ù†Ù‡ ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†ÛŒØ¯.",
                uploadPrompt: "Ø¹Ú©Ø³ÛŒ Ø§Ø² Ù…ÙˆØ§Ø¯ Ø§ÙˆÙ„ÛŒÙ‡ Ø®ÙˆØ¯ Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯",
                uploadButton: "Ø§Ù†ØªØ®Ø§Ø¨ Ø¹Ú©Ø³",
                analyzing: "Ø¯Ø± Ø­Ø§Ù„ ØªØ¬Ø²ÛŒÙ‡ Ùˆ ØªØ­Ù„ÛŒÙ„ Ù…ÙˆØ§Ø¯...",
                suggestionsPrompt: "Ú†Ù†Ø¯ Ø§ÛŒØ¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§:",
                generateRecipe: "ØªÙˆÙ„ÛŒØ¯ Ø¯Ø³ØªÙˆØ± Ù¾Ø®Øª",
                generatingRecipe: "Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ø¯Ø³ØªÙˆØ± Ù¾Ø®Øª...",
                generatingImage: "Ø¯Ø± Ø­Ø§Ù„ Ù†Ù‚Ø§Ø´ÛŒ ØºØ°Ø§ÛŒ Ø´Ù…Ø§...",
                generatingVideo: "Ø¯Ø± Ø­Ø§Ù„ Ú©Ø§Ø±Ú¯Ø±Ø¯Ø§Ù†ÛŒ ÙˆÛŒØ¯ÛŒÙˆÛŒ Ø¢Ø´Ù¾Ø²ÛŒ Ø´Ù…Ø§...",
                startCooking: "Ø´Ø±ÙˆØ¹ Ø¯Ø³ØªÛŒØ§Ø± Ø²Ù†Ø¯Ù‡ Ø¢Ø´Ù¾Ø²ÛŒ",
                videoReady: "ÙˆÛŒØ¯ÛŒÙˆÛŒ Ø¢Ø´Ù¾Ø²ÛŒ Ø´Ù…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª!",
                watchVideo: "ØªÙ…Ø§Ø´Ø§ÛŒ ÙˆÛŒØ¯ÛŒÙˆ",
                startOver: "Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯",
                error: "Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡â€ŒØ§ÛŒ Ø±Ø® Ø¯Ø§Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.",
                cookingAssistantTitle: "Ø¯Ø³ØªÛŒØ§Ø± Ø²Ù†Ø¯Ù‡ Ø¢Ø´Ù¾Ø²ÛŒ",
                listening: "Ø¯Ø± Ø­Ø§Ù„ Ú¯ÙˆØ´ Ø¯Ø§Ø¯Ù†...",
                speakNow: "Ø§Ù„Ø§Ù† ØµØ­Ø¨Øª Ú©Ù†ÛŒØ¯...",
                processing: "Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...",
                micIsOff: "Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ø®Ø§Ù…ÙˆØ´ Ø§Ø³Øª",
                user: "Ø´Ù…Ø§",
                assistant: "Ø¯Ø³ØªÛŒØ§Ø±",
                endSession: "Ù¾Ø§ÛŒØ§Ù† Ø¬Ù„Ø³Ù‡",
                confirmEndSession: "Ø¢ÛŒØ§ Ø§Ø² Ù¾Ø§ÛŒØ§Ù† Ø¯Ø§Ø¯Ù† Ø¨Ù‡ Ø¬Ù„Ø³Ù‡ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ",
                yes: "Ø¨Ù„Ù‡",
                no: "Ø®ÛŒØ±",
            },
        };
        // ========================================================================
        // --- END OF i18n/translations.ts ---
        // ========================================================================


        // ========================================================================
        // --- START OF utils/audioUtils.ts ---
        // ========================================================================
        function decode(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        async function decodeAudioData(data, ctx, sampleRate, numChannels) {
            const dataInt16 = new Int16Array(data.buffer);
            const frameCount = dataInt16.length / numChannels;
            const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

            for (let channel = 0; channel < numChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < frameCount; i++) {
                    channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
                }
            }
            return buffer;
        }

        function encode(bytes) {
            let binary = '';
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        // ========================================================================
        // --- END OF utils/audioUtils.ts ---
        // ========================================================================


        // ========================================================================
        // --- START OF services/geminiService.ts ---
        // ========================================================================
        const getAiClient = () => new GoogleGenAI({ apiKey: process.env.API_KEY });

        const generateRecipe = async (imageData, mimeType, suggestions, language) => {
            const ai = getAiClient();
            const langMap = { en: "English", fa: "Persian (Farsi)" };
            const prompt = `Analyze the ingredients in this image. Based on these ingredients, generate a detailed recipe for "${suggestions}". The recipe should be in ${langMap[language]}. Include a creative name for the dish, a list of ingredients with quantities, and step-by-step instructions. The response must be in markdown format.`;

            const imagePart = {
                inlineData: {
                    data: imageData,
                    mimeType: mimeType,
                },
            };
            const textPart = { text: prompt };

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: { parts: [imagePart, textPart] },
            });
            return response.text;
        };

        const generateImage = async (recipe) => {
            const ai = getAiClient();
            const prompt = `Generate a photorealistic image of the following dish, styled for a gourmet food magazine: ${recipe}`;
            
            const response = await ai.models.generateImages({
                model: 'imagen-4.0-generate-001',
                prompt: prompt,
                config: {
                    numberOfImages: 1,
                    aspectRatio: '16:9',
                },
            });
            const base64ImageBytes = response.generatedImages[0].image.imageBytes;
            return `data:image/png;base64,${base64ImageBytes}`;
        };

        const generateVideo = async (recipe) => {
            const hasApiKey = await window.aistudio.hasSelectedApiKey();
            if (!hasApiKey) {
                await window.aistudio.openSelectKey();
            }

            const ai = getAiClient();
            const prompt = `Create a short, dynamic cooking video based on this recipe: ${recipe}. Show close-ups of the ingredients and the key cooking steps. The style should be upbeat and modern, suitable for social media.`;
            
            let operation = await ai.models.generateVideos({
                model: 'veo-3.1-fast-generate-preview',
                prompt: prompt,
                config: {
                    numberOfVideos: 1,
                    resolution: '720p',
                    aspectRatio: '9:16'
                }
            });

            while (!operation.done) {
                await new Promise(resolve => setTimeout(resolve, 5000));
                try {
                    operation = await ai.operations.getVideosOperation({ operation: operation });
                } catch (e) {
                    if (e.message.includes("Requested entity was not found.")) {
                       await window.aistudio.openSelectKey();
                       // re-throw to be caught by the caller
                       throw new Error("API key invalid, please re-select.");
                    }
                    throw e; // re-throw other errors
                }
            }
            const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
            if (!downloadLink) {
                 throw new Error("Video generation failed to produce a download link.");
            }
            const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
            const videoBlob = await response.blob();
            return URL.createObjectURL(videoBlob);
        };
        // ========================================================================
        // --- END OF services/geminiService.ts ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/icons.tsx ---
        // ========================================================================
        const UploadIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
          </svg>
        );
        const CheckCircleIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
            </svg>
        );
        const CircleIcon = ({ className }) => (
            <svg viewBox="0 0 8 8" className={className}>
                <circle cx="4" cy="4" r="4" />
            </svg>
        );
        const FlameIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7.C14.05 5.02 16 7.464 16 10c0 1-1.05 2.05-2.05 3.05C13.455 13.555 14 15 14 15a8.003 8.003 0 013.657 3.657z" />
            </svg>
        );
        const MicIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm5 10.5a.5.5 0 01.5.5v.5a.5.5 0 01-1 0V15a.5.5 0 01.5-.5z" clipRule="evenodd" />
                <path d="M5 8a5 5 0 1010 0V4a5 5 0 10-10 0v4zM10 18a8 8 0 100-16 8 8 0 000 16z" />
            </svg>
        );
        const MicOffIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM5 8a5 5 0 0110 0v4a5 5 0 01-10 0V8zm1.05 7.95a.5.5 0 00.7.7l6.5-6.5a.5.5 0 00-.7-.7l-6.5 6.5z" clipRule="evenodd" />
            </svg>
        );
        const StopIcon = () => (
             <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
        );
        // ========================================================================
        // --- END OF components/icons.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/LanguageSelector.tsx ---
        // ========================================================================
        const LanguageSelector = ({ language, setLanguage, t }) => {
            const toggleLanguage = () => {
                const newLang = language === Language.EN ? Language.FA : Language.EN;
                setLanguage(newLang);
                document.documentElement.lang = newLang;
                document.documentElement.dir = newLang === Language.FA ? 'rtl' : 'ltr';
            };

            return (
                <div className="absolute top-4 right-4">
                    <button
                        onClick={toggleLanguage}
                        className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-md text-white transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-purple-500"
                    >
                        {language === Language.EN ? 'ÙØ§Ø±Ø³ÛŒ' : 'English'}
                    </button>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/LanguageSelector.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/ImageUploader.tsx ---
        // ========================================================================
        const ImageUploader = ({ onImageUpload, t }) => {
            const [isDragging, setIsDragging] = React.useState(false);
            const fileInputRef = React.useRef(null);

            const handleFile = (file) => {
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        onImageUpload(e.target.result.split(',')[1], file.type);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDragEnter = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); };
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    handleFile(e.dataTransfer.files[0]);
                    e.dataTransfer.clearData();
                }
            };

            return (
                <div
                    className={`w-full max-w-lg p-8 border-2 border-dashed rounded-xl transition-colors duration-300 ${isDragging ? 'border-purple-500 bg-gray-800' : 'border-gray-600 hover:border-purple-400'}`}
                    onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                    onDragOver={handleDragOver}
                    onDrop={handleDrop}
                >
                    <div className="text-center">
                        <h2 className="text-2xl font-semibold text-gray-200 mb-4 font-lora">{t.uploadPrompt}</h2>
                        <button
                            onClick={() => fileInputRef.current.click()}
                            className="inline-flex items-center px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-purple-500"
                        >
                            <UploadIcon />
                            {t.uploadButton}
                        </button>
                        <input
                            type="file"
                            ref={fileInputRef}
                            onChange={(e) => handleFile(e.target.files[0])}
                            className="hidden"
                            accept="image/*"
                        />
                    </div>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/ImageUploader.tsx ---
        // ========================================================================

        // ========================================================================
        // --- START OF components/RecipeSuggestions.tsx ---
        // ========================================================================
        const RecipeSuggestions = ({ suggestions, onSelect, t }) => {
             return (
                <div className="w-full max-w-2xl text-center fade-in">
                    <h2 className="text-3xl font-bold mb-6 font-lora">{t.suggestionsPrompt}</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {suggestions.map((suggestion, index) => (
                            <button
                                key={index}
                                onClick={() => onSelect(suggestion)}
                                className="p-6 bg-gray-800 rounded-lg text-left hover:bg-purple-800/50 border border-gray-700 hover:border-purple-500 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-purple-500"
                            >
                                <span className="text-lg font-semibold text-gray-100">{suggestion}</span>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/RecipeSuggestions.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/RecipeDisplay.tsx ---
        // ========================================================================
        const RecipeDisplay = ({ recipe, image, onStartOver, onGenerateVideo, onStartCooking, t }) => {
            const createMarkup = (markdown) => {
                const html = markdown
                  .replace(/^# (.*$)/gim, '<h1 class="text-3xl font-bold font-lora text-purple-300 my-4">$1</h1>')
                  .replace(/^## (.*$)/gim, '<h2 class="text-2xl font-semibold font-lora text-purple-400 mt-6 mb-3">$1</h2>')
                  .replace(/^### (.*$)/gim, '<h3 class="text-xl font-semibold font-lora mt-4 mb-2">$1</h3>')
                  .replace(/\*\*(.*)\*\*/g, '<strong>$1</strong>')
                  .replace(/\*(.*)\*/g, '<em>$1</em>')
                  .replace(/^\* (.*$)/gim, '<li class="ml-6 mb-2 flex items-start"><span class="mr-2 mt-1.5 text-purple-400">&bull;</span>$1</li>')
                  .replace(/(\r\n|\n\r|\r|\n){2,}/g, '<br/><br/>') // Handle line breaks
                  .replace(/(\r\n|\n\r|\r|\n)(?!\<li|\<h)/g, '<br/>'); // Handle single line breaks for non-list/header items
                return { __html: html.replace(/<br\/><br\/>(\<li)/g, '$1') }; // Cleanup extra breaks before lists
            };

            return (
                <div className="w-full max-w-5xl mx-auto p-4 md:p-8 bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 fade-in">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <img src={image} alt="Generated dish" className="w-full h-auto rounded-xl shadow-lg object-cover aspect-video" />
                            <div className="mt-6 flex flex-col sm:flex-row gap-4">
                                <button
                                    onClick={onGenerateVideo}
                                    className="flex-1 inline-flex items-center justify-center px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-green-500"
                                >
                                    ğŸ¬ {t.generatingVideo}
                                </button>
                                <button
                                    onClick={onStartCooking}
                                    className="flex-1 inline-flex items-center justify-center px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500"
                                >
                                  <FlameIcon /> {t.startCooking}
                                </button>
                            </div>
                        </div>
                        <div className="prose prose-invert max-w-none text-gray-300" dangerouslySetInnerHTML={createMarkup(recipe)}></div>
                    </div>
                     <div className="text-center mt-8">
                        <button
                            onClick={onStartOver}
                            className="px-6 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500"
                        >
                            {t.startOver}
                        </button>
                    </div>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/RecipeDisplay.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/VideoGenerator.tsx ---
        // ========================================================================
        const VideoGenerator = ({ videoUrl, onStartOver, t }) => {
            return (
                <div className="w-full max-w-md text-center fade-in">
                    <h2 className="text-3xl font-bold mb-6 font-lora text-green-400">{t.videoReady}</h2>
                    <div className="aspect-w-9 aspect-h-16 rounded-2xl overflow-hidden shadow-2xl border-4 border-purple-500">
                        <video
                            src={videoUrl}
                            controls
                            autoPlay
                            className="w-full h-full object-cover"
                        >
                            Your browser does not support the video tag.
                        </video>
                    </div>
                    <div className="mt-8">
                        <button
                            onClick={onStartOver}
                            className="px-8 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-purple-500"
                        >
                            {t.startOver}
                        </button>
                    </div>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/VideoGenerator.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF components/CookingAssistant.tsx ---
        // ========================================================================
        const CookingAssistant = ({ recipe, onEndSession, t }) => {
            const { LiveServerMessage, Modality, Type } = GoogleGenAI;
            
            const [isListening, setIsListening] = React.useState(false);
            const [isMicOn, setIsMicOn] = React.useState(true);
            const [isEnding, setIsEnding] = React.useState(false);
            const [transcripts, setTranscripts] = React.useState([]);

            const sessionPromiseRef = React.useRef(null);
            const inputAudioContextRef = React.useRef(null);
            const outputAudioContextRef = React.useRef(null);
            const scriptProcessorRef = React.useRef(null);
            const mediaStreamSourceRef = React.useRef(null);
            const streamRef = React.useRef(null);
            const nextStartTimeRef = React.useRef(0);
            const audioSourcesRef = React.useRef(new Set());
            let currentInputTranscription = '';
            let currentOutputTranscription = '';

            const startSession = async () => {
                try {
                    const ai = getAiClient();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    streamRef.current = stream;

                    inputAudioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    outputAudioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                    
                    setIsListening(true);
                    
                    sessionPromiseRef.current = ai.live.connect({
                        model: 'gemini-2.5-flash-native-audio-preview-09-2025',
                        config: {
                            responseModalities: [Modality.AUDIO],
                            inputAudioTranscription: {},
                            outputAudioTranscription: {},
                            systemInstruction: `You are a helpful cooking assistant. Guide the user through the following recipe. Be encouraging and clear. Recipe: ${recipe}`,
                        },
                        callbacks: {
                            onopen: () => {
                                const source = inputAudioContextRef.current.createMediaStreamSource(stream);
                                mediaStreamSourceRef.current = source;
                                const scriptProcessor = inputAudioContextRef.current.createScriptProcessor(4096, 1, 1);
                                scriptProcessorRef.current = scriptProcessor;

                                scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                                    if (!isMicOn) return;
                                    const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                                    const pcmBlob = {
                                        data: encode(new Uint8Array(new Int16Array(inputData.map(x => x * 32768)).buffer)),
                                        mimeType: 'audio/pcm;rate=16000',
                                    };
                                    sessionPromiseRef.current.then((session) => {
                                        session.sendRealtimeInput({ media: pcmBlob });
                                    });
                                };
                                source.connect(scriptProcessor);
                                scriptProcessor.connect(inputAudioContextRef.current.destination);
                            },
                            onmessage: async (message) => {
                                if (message.serverContent?.inputTranscription) {
                                    currentInputTranscription += message.serverContent.inputTranscription.text;
                                }
                                if (message.serverContent?.outputTranscription) {
                                    currentOutputTranscription += message.serverContent.outputTranscription.text;
                                }
                                if (message.serverContent?.turnComplete) {
                                    setTranscripts(prev => [
                                        ...prev,
                                        { speaker: 'user', text: currentInputTranscription },
                                        { speaker: 'assistant', text: currentOutputTranscription }
                                    ]);
                                    currentInputTranscription = '';
                                    currentOutputTranscription = '';
                                }

                                const base64EncodedAudioString = message.serverContent?.modelTurn?.parts[0]?.inlineData.data;
                                if (base64EncodedAudioString) {
                                    nextStartTimeRef.current = Math.max(nextStartTimeRef.current, outputAudioContextRef.current.currentTime);
                                    const audioBuffer = await decodeAudioData(decode(base64EncodedAudioString), outputAudioContextRef.current, 24000, 1);
                                    const source = outputAudioContextRef.current.createBufferSource();
                                    source.buffer = audioBuffer;
                                    source.connect(outputAudioContextRef.current.destination);
                                    source.addEventListener('ended', () => {
                                        audioSourcesRef.current.delete(source);
                                    });
                                    source.start(nextStartTimeRef.current);
                                    nextStartTimeRef.current += audioBuffer.duration;
                                    audioSourcesRef.current.add(source);
                                }
                            },
                            onerror: (e) => console.error('Live session error:', e),
                            onclose: () => console.log('Live session closed'),
                        },
                    });
                } catch (error) {
                    console.error("Failed to start cooking assistant:", error);
                }
            };

            const stopSession = React.useCallback(() => {
                setIsListening(false);
                setIsEnding(false);

                // Stop audio sources
                audioSourcesRef.current.forEach(source => source.stop());
                audioSourcesRef.current.clear();

                // Stop mic stream
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                }

                // Disconnect audio nodes
                if (scriptProcessorRef.current) {
                    scriptProcessorRef.current.disconnect();
                    scriptProcessorRef.current = null;
                }
                if (mediaStreamSourceRef.current) {
                    mediaStreamSourceRef.current.disconnect();
                    mediaStreamSourceRef.current = null;
                }
                
                // Close audio contexts
                if (inputAudioContextRef.current && inputAudioContextRef.current.state !== 'closed') {
                    inputAudioContextRef.current.close();
                }
                if (outputAudioContextRef.current && outputAudioContextRef.current.state !== 'closed') {
                    outputAudioContextRef.current.close();
                }

                // Close session
                if (sessionPromiseRef.current) {
                    sessionPromiseRef.current.then(session => session.close());
                    sessionPromiseRef.current = null;
                }
                onEndSession();
            }, [onEndSession]);
            
            React.useEffect(() => {
                startSession();
                return () => {
                   stopSession();
                };
            }, []);
            
             const handleToggleMic = () => {
                setIsMicOn(prev => !prev);
            };

            const handleEndSessionClick = () => {
                setIsEnding(true);
            };

            return (
                <div className="w-full max-w-2xl mx-auto p-6 bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 fade-in">
                    <h2 className="text-2xl font-bold font-lora text-center mb-4">{t.cookingAssistantTitle}</h2>
                    
                    {isEnding && (
                        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50">
                            <div className="bg-gray-700 p-6 rounded-lg shadow-xl">
                                <p className="text-lg mb-4">{t.confirmEndSession}</p>
                                <div className="flex justify-end gap-4">
                                    <button onClick={() => setIsEnding(false)} className="px-4 py-2 bg-gray-600 rounded hover:bg-gray-500">{t.no}</button>
                                    <button onClick={stopSession} className="px-4 py-2 bg-red-600 rounded hover:bg-red-500">{t.yes}</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    <div className="h-96 overflow-y-auto p-4 bg-gray-900/50 rounded-lg mb-4 flex flex-col-reverse">
                        <div className="space-y-4">
                         {transcripts.slice().reverse().map((t, i) => (
                           <div key={i} className={`flex items-start gap-3 ${t.speaker === 'user' ? 'justify-end' : ''}`}>
                             <div className={`max-w-xs md:max-w-md p-3 rounded-lg ${t.speaker === 'user' ? 'bg-purple-600' : 'bg-gray-700'}`}>
                               <p className="text-sm">{t.text}</p>
                             </div>
                           </div>
                         ))}
                        </div>
                    </div>
                    
                    <div className="flex flex-col items-center justify-center gap-4">
                         <div className="flex items-center gap-2 text-gray-400">
                             {isMicOn ? <CircleIcon className="w-2 h-2 text-red-500 animate-pulse" /> : <CircleIcon className="w-2 h-2 text-gray-500" />}
                             <span>{isMicOn ? t.listening : t.micIsOff}</span>
                         </div>
                        <button onClick={handleToggleMic} className={`p-4 rounded-full transition-colors ${isMicOn ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'}`}>
                            {isMicOn ? <MicIcon /> : <MicOffIcon />}
                        </button>
                        <button onClick={handleEndSessionClick} className="flex items-center gap-2 px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-lg text-sm">
                            <StopIcon /> {t.endSession}
                        </button>
                    </div>
                </div>
            );
        };
        // ========================================================================
        // --- END OF components/CookingAssistant.tsx ---
        // ========================================================================


        // ========================================================================
        // --- START OF App.tsx ---
        // ========================================================================
        const App = () => {
            const [appState, setAppState] = React.useState(AppState.IDLE);
            const [language, setLanguage] = React.useState(Language.EN);
            const [error, setError] = React.useState(null);
            const [imageData, setImageData] = React.useState(null);
            const [mimeType, setMimeType] = React.useState(null);
            const [suggestions, setSuggestions] = React.useState([]);
            const [recipe, setRecipe] = React.useState(null);
            const [generatedImage, setGeneratedImage] = React.useState(null);
            const [videoUrl, setVideoUrl] = React.useState(null);

            const t = translations[language];

            const handleImageUpload = async (data, type) => {
                setImageData(data);
                setMimeType(type);
                setAppState(AppState.ANALYZING);
                try {
                    const ai = getAiClient();
                    const prompt = "Analyze this image of ingredients and suggest 4 creative, distinct, and appealing recipe ideas. Respond with only a JSON array of strings, like [\"Recipe 1\", \"Recipe 2\", \"Recipe 3\", \"Recipe 4\"]. Do not include any other text or markdown.";
                    const imagePart = { inlineData: { data, mimeType: type } };
                    
                    const response = await ai.models.generateContent({
                        model: 'gemini-2.5-flash',
                        contents: { parts: [imagePart, { text: prompt }] },
                        config: { responseMimeType: 'application/json' }
                    });
                    
                    const text = response.text.trim();
                    setSuggestions(JSON.parse(text));
                    setAppState(AppState.SUGGESTING);
                } catch (err) {
                    console.error(err);
                    setError(t.error);
                    setAppState(AppState.ERROR);
                }
            };
            
            const handleSuggestionSelect = async (selectedSuggestion) => {
                setAppState(AppState.GENERATING_IMAGE);
                 try {
                    const recipeText = await generateRecipe(imageData, mimeType, selectedSuggestion, language);
                    setRecipe(recipeText);
                    const imageUrl = await generateImage(recipeText);
                    setGeneratedImage(imageUrl);
                    setAppState(AppState.DISPLAYING_RECIPE);
                } catch (err) {
                    console.error(err);
                    setError(t.error);
                    setAppState(AppState.ERROR);
                }
            };

            const handleGenerateVideo = async () => {
                setAppState(AppState.GENERATING_VIDEO);
                try {
                    const url = await generateVideo(recipe);
                    setVideoUrl(url);
                    setAppState(AppState.DISPLAYING_VIDEO);
                } catch (err) {
                    console.error(err);
                    setError(t.error);
                    setAppState(AppState.ERROR);
                }
            };

            const handleStartCooking = () => {
                setAppState(AppState.COOKING);
            };

            const resetState = () => {
                setAppState(AppState.IDLE);
                setError(null);
                setImageData(null);
                setMimeType(null);
                setSuggestions([]);
                setRecipe(null);
                setGeneratedImage(null);
                setVideoUrl(null);
            };
            
            const renderContent = () => {
                switch (appState) {
                    case AppState.IDLE:
                        return <ImageUploader onImageUpload={handleImageUpload} t={t} />;
                    case AppState.ANALYZING:
                        return <div className="text-center"><div className="loader mx-auto"></div><p className="mt-4 text-xl">{t.analyzing}</p></div>;
                    case AppState.SUGGESTING:
                        return <RecipeSuggestions suggestions={suggestions} onSelect={handleSuggestionSelect} t={t} />;
                    case AppState.GENERATING_IMAGE:
                         return <div className="text-center"><div className="loader mx-auto"></div><p className="mt-4 text-xl">{t.generatingImage}</p></div>;
                    case AppState.DISPLAYING_RECIPE:
                        return <RecipeDisplay recipe={recipe} image={generatedImage} onStartOver={resetState} onGenerateVideo={handleGenerateVideo} onStartCooking={handleStartCooking} t={t} />;
                    case AppState.GENERATING_VIDEO:
                        return <div className="text-center"><div className="loader mx-auto"></div><p className="mt-4 text-xl">{t.generatingVideo}</p></div>;
                    case AppState.DISPLAYING_VIDEO:
                         return <VideoGenerator videoUrl={videoUrl} onStartOver={resetState} t={t} />;
                    case AppState.COOKING:
                         return <CookingAssistant recipe={recipe} onEndSession={resetState} t={t} />;
                    case AppState.ERROR:
                        return (
                            <div className="text-center text-red-400">
                                <p className="text-xl mb-4">{error}</p>
                                <button onClick={resetState} className="px-6 py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700">{t.startOver}</button>
                            </div>
                        );
                    default:
                        return null;
                }
            };

            return (
                <main className="min-h-screen w-full flex flex-col items-center justify-center p-4">
                    <LanguageSelector language={language} setLanguage={setLanguage} t={t} />
                    <div className="text-center mb-12">
                         <h1 className="text-5xl md:text-6xl font-bold font-lora text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">
                            {t.title}
                        </h1>
                        <p className="text-lg text-gray-300 mt-2">{t.subtitle}</p>
                    </div>
                    <div className="w-full flex items-center justify-center">
                        {renderContent()}
                    </div>
                </main>
            );
        };
        // ========================================================================
        // --- END OF App.tsx ---
        // ========================================================================

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
